<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Stream</title>
    <style>
        :root {
            --primary-bg: #0a192f;
            --secondary-bg: #172a45;
            --accent-color: #64ffda;
            --text-primary: #e6f1ff;
            --text-secondary: #8892b0;
            --hover-color: #1e3a8a;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--primary-bg);
            color: var(--text-primary);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--secondary-bg);
        }
        
        .back-btn {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }
        
        .back-btn:hover {
            background-color: var(--hover-color);
        }
        
        .anime-title {
            font-size: 24px;
            margin: 20px 0;
            color: var(--accent-color);
        }
        
        .stream-container {
            background-color: var(--secondary-bg);
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .video-container {
            position: relative;
            padding-bottom: 56.25%; /* 16:9 aspect ratio */
            height: 0;
            overflow: hidden;
        }
        
        .video-container iframe,
        .video-container video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }
        
        .server-options {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .server-btn {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            border: 1px solid var(--accent-color);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .server-btn.active {
            background-color: var(--accent-color);
            color: var(--primary-bg);
            font-weight: bold;
        }
        
        .server-btn:hover {
            background-color: var(--hover-color);
        }
        
        .download-options {
            margin: 20px 0;
        }
        
        .download-section {
            margin-bottom: 20px;
        }
        
        .download-section h3 {
            color: var(--accent-color);
            border-bottom: 1px solid var(--secondary-bg);
            padding-bottom: 5px;
        }
        
        .download-links {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .download-link {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 4px;
            text-decoration: none;
            transition: all 0.3s ease;
            border: 1px solid var(--text-secondary);
        }
        
        .download-link:hover {
            background-color: var(--hover-color);
        }
        
        .episodes-container {
            margin-top: 30px;
        }
        
        .episodes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .episodes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
        }
        
        .episode-btn {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            border: none;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .episode-btn:hover {
            background-color: var(--hover-color);
        }
        
        .episode-btn.current {
            background-color: var(--accent-color);
            color: var(--primary-bg);
            font-weight: bold;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        
        .pagination-btn {
            background-color: var(--secondary-bg);
            color: var(--text-primary);
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .pagination-btn:hover {
            background-color: var(--hover-color);
        }
        
        .pagination-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
            font-size: 18px;
            color: var(--text-secondary);
        }
        
        .error-message {
            color: #ff6b6b;
            text-align: center;
            padding: 20px;
            background-color: var(--secondary-bg);
            border-radius: 8px;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .episodes-grid {
                grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            }
            
            .server-options {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="/" class="back-btn">‚Üê Back to Home</a>
            <h1 class="anime-title" id="animeTitle">Loading...</h1>
        </header>
        
        <div class="stream-container">
            <div class="video-container" id="videoContainer">
                <div class="loading">Loading video...</div>
            </div>
        </div>
        
        <div class="server-options">
            <button class="server-btn active" id="animeHeavenBtn">AnimeHeaven</button>
            <button class="server-btn" id="gogoAnimeBtn">GogoAnime</button>
        </div>
        
        <div class="download-options">
            <div class="download-section">
                <h3>Download Options</h3>
                <div class="download-links" id="downloadLinks">
                    <!-- Download links will be populated here -->
                </div>
            </div>
        </div>
        
        <div class="episodes-container">
            <div class="episodes-header">
                <h2>Episodes</h2>
            </div>
            <div class="episodes-grid" id="episodesGrid">
                <!-- Episodes will be populated here -->
            </div>
            <div class="pagination" id="pagination">
                <!-- Pagination buttons will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // Extract anime ID and episode number from URL
        const pathParts = window.location.pathname.split('/');
        const animeId = pathParts[2];
        let currentEpisode = parseInt(pathParts[3]) || 1;
        
        // State variables
        let animeData = null;
        let totalEpisodes = 0;
        let currentPage = 1;
        const episodesPerPage = 100;
        let currentServer = 'animeheaven';
        
        // DOM elements
        const animeTitleElement = document.getElementById('animeTitle');
        const videoContainer = document.getElementById('videoContainer');
        const animeHeavenBtn = document.getElementById('animeHeavenBtn');
        const gogoAnimeBtn = document.getElementById('gogoAnimeBtn');
        const downloadLinks = document.getElementById('downloadLinks');
        const episodesGrid = document.getElementById('episodesGrid');
        const pagination = document.getElementById('pagination');
        
        // Initialize the page
        document.addEventListener('DOMContentLoaded', () => {
            fetchAnimeData();
            setupEventListeners();
        });
        
        function setupEventListeners() {
            animeHeavenBtn.addEventListener('click', () => switchServer('animeheaven'));
            gogoAnimeBtn.addEventListener('click', () => switchServer('gogoanime'));
            
            // Handle back/forward navigation
            window.addEventListener('popstate', () => {
                const pathParts = window.location.pathname.split('/');
                const newEpisode = parseInt(pathParts[3]) || 1;
                if (newEpisode !== currentEpisode) {
                    currentEpisode = newEpisode;
                    loadEpisode();
                }
            });
        }
        
        function switchServer(server) {
            if (server === currentServer) return;
            
            currentServer = server;
            
            // Update active button
            animeHeavenBtn.classList.remove('active');
            gogoAnimeBtn.classList.remove('active');
            
            if (server === 'animeheaven') {
                animeHeavenBtn.classList.add('active');
            } else {
                gogoAnimeBtn.classList.add('active');
            }
            
            loadEpisode();
        }
        
        async function fetchAnimeData() {
            try {
                // Fetch anime data from AniList
                const query = `
                    query ($id: Int) {
                        Media(id: $id, type: ANIME) {
                            title {
                                english
                                romaji
                            }
                            episodes
                        }
                    }
                `;
                
                const variables = { id: parseInt(animeId) };
                
                const response = await fetch('https://graphql.anilist.co', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({
                        query,
                        variables
                    })
                });
                
                const data = await response.json();
                
                if (data.errors) {
                    throw new Error(data.errors[0].message);
                }
                
                animeData = data.data.Media;
                totalEpisodes = animeData.episodes || 1;
                
                // Set anime title (prefer English, fallback to romaji)
                const title = animeData.title.english || animeData.title.romaji;
                animeTitleElement.textContent = title;
                
                // Load the episode and setup episodes list
                loadEpisode();
                setupEpisodesList();
            } catch (error) {
                console.error('Error fetching anime data:', error);
                animeTitleElement.textContent = 'Failed to load anime';
                videoContainer.innerHTML = '<div class="error-message">Failed to load anime data. Please try again later.</div>';
            }
        }
        
        async function loadEpisode() {
            try {
                videoContainer.innerHTML = '<div class="loading">Loading video...</div>';
                
                const title = animeData.title.english || animeData.title.romaji;
                
                if (currentServer === 'animeheaven') {
                    await loadAnimeHeavenStream(title);
                } else {
                    await loadGogoAnimeStream(title);
                }
                
                // Load download options
                loadDownloadOptions(title);
                
                // Update current episode button in episodes list
                updateCurrentEpisodeButton();
            } catch (error) {
                console.error('Error loading episode:', error);
                videoContainer.innerHTML = '<div class="error-message">Failed to load video. Please try another server or episode.</div>';
            }
        }
        
        async function loadAnimeHeavenStream(title) {
            // Clean the title for URL
            const cleanTitle = encodeURIComponent(title.replace(/[^a-zA-Z0-9 ]/g, '').trim());
            
            // Fetch video URL from AnimeHeaven API
            const apiUrl = `http://txtorg-anih.hf.space/video?name=${cleanTitle}&episode=${currentEpisode}`;
            const response = await fetchWithFallback(apiUrl);
            
            if (!response.ok) {
                throw new Error('Failed to fetch AnimeHeaven stream');
            }
            
            const data = await response.json();
            
            if (!data.videoUrl) {
                throw new Error('No video URL found');
            }
            
            // Create video element
            videoContainer.innerHTML = `
                <video controls autoplay style="width:100%; height:100%;">
                    <source src="${data.videoUrl}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            `;
        }
        
        async function loadGogoAnimeStream(title) {
            // Clean the title for URL
            const cleanTitle = encodeURIComponent(title.replace(/[^a-zA-Z0-9 ]/g, '').trim());
            
            // Step 1: Get episode URL from GogoAnime API
            const gogoApiUrl = `https://reikerxx-animedl.hf.space/anime/${cleanTitle}/${currentEpisode}`;
            const gogoResponse = await fetchWithFallback(gogoApiUrl);
            
            if (!gogoResponse.ok) {
                throw new Error('Failed to fetch GogoAnime episode URL');
            }
            
            const gogoData = await gogoResponse.json();
            
            if (!gogoData.episodeUrl) {
                throw new Error('No GogoAnime episode URL found');
            }
            
            // Step 2: Get iframe URL
            const iframeApiUrl = `https://txtorg-anih.hf.space/iframe?url=${encodeURIComponent(gogoData.episodeUrl)}`;
            const iframeResponse = await fetchWithFallback(iframeApiUrl);
            
            if (!iframeResponse.ok) {
                throw new Error('Failed to fetch GogoAnime iframe URL');
            }
            
            const iframeData = await iframeResponse.json();
            
            if (!iframeData.iframeUrl) {
                throw new Error('No GogoAnime iframe URL found');
            }
            
            // Step 3: Get final streaming URL
            const finalApiUrl = `https://txtorg-anih.hf.space/q?q=${encodeURIComponent(iframeData.iframeUrl)}`;
            const finalResponse = await fetchWithFallback(finalApiUrl);
            
            if (!finalResponse.ok) {
                throw new Error('Failed to fetch final GogoAnime stream URL');
            }
            
            const finalData = await finalResponse.json();
            
            if (!finalData.url) {
                throw new Error('No final streaming URL found');
            }
            
            // Create iframe element
            videoContainer.innerHTML = `
                <iframe src="${finalData.url}" allowfullscreen></iframe>
            `;
        }
        
        async function loadDownloadOptions(title) {
            try {
                downloadLinks.innerHTML = '<div class="loading">Loading download options...</div>';
                
                const cleanTitle = encodeURIComponent(title.replace(/[^a-zA-Z0-9 ]/g, '').trim());
                
                // AnimeHeaven download
                const animeHeavenApiUrl = `http://txtorg-anih.hf.space/video?name=${cleanTitle}&episode=${currentEpisode}`;
                const animeHeavenResponse = await fetchWithFallback(animeHeavenApiUrl);
                
                let animeHeavenLink = '';
                if (animeHeavenResponse.ok) {
                    const data = await animeHeavenResponse.json();
                    if (data.videoUrl) {
                        animeHeavenLink = data.videoUrl;
                    }
                }
                
                // TokyoInsider download
                const tokyoApiUrl = `https://reaperxxxx-anime.hf.space/api/anime2?name=${cleanTitle}&episode=${currentEpisode}`;
                const tokyoResponse = await fetchWithFallback(tokyoApiUrl);
                
                let tokyoLinks = [];
                if (tokyoResponse.ok) {
                    const data = await tokyoResponse.json();
                    if (data.Downloads) {
                        Object.entries(data.Downloads).forEach(([quality, info]) => {
                            if (info !== "Not available" && info.url) {
                                tokyoLinks.push({
                                    quality,
                                    url: info.url
                                });
                            }
                        });
                    }
                }
                
                // 9anime download
                const nineAnimeApiUrl = `https://txtorg-anih.hf.space/api/anime-download?q=${cleanTitle}&episode=${currentEpisode}`;
                const nineAnimeResponse = await fetchWithFallback(nineAnimeApiUrl);
                
                let nineAnimeLinks = [];
                if (nineAnimeResponse.ok) {
                    const data = await nineAnimeResponse.json();
                    if (data.download_links) {
                        data.download_links.forEach(link => {
                            nineAnimeLinks.push({
                                quality: link.quality,
                                url: link.link
                            });
                        });
                    }
                }
                
                // Render download links
                let html = '';
                
                // AnimeHeaven
                if (animeHeavenLink) {
                    html += `<a href="${animeHeavenLink}" class="download-link" download>Download from AnimeHeaven</a>`;
                }
                
                // TokyoInsider
                if (tokyoLinks.length > 0) {
                    tokyoLinks.forEach(link => {
                        html += `<a href="${link.url}" class="download-link" download>TokyoInsider (${link.quality})</a>`;
                    });
                }
                
                // 9anime
                if (nineAnimeLinks.length > 0) {
                    nineAnimeLinks.forEach(link => {
                        html += `<a href="${link.url}" class="download-link" download>9anime (${link.quality})</a>`;
                    });
                }
                
                if (html === '') {
                    html = '<div class="error-message">No download options available for this episode.</div>';
                }
                
                downloadLinks.innerHTML = html;
            } catch (error) {
                console.error('Error loading download options:', error);
                downloadLinks.innerHTML = '<div class="error-message">Failed to load download options. Please try again later.</div>';
            }
        }
        
        function setupEpisodesList() {
            // Clear existing content
            episodesGrid.innerHTML = '';
            
            // Calculate pagination
            const totalPages = Math.ceil(totalEpisodes / episodesPerPage);
            
            // Determine which episodes to show on current page
            const startEpisode = (currentPage - 1) * episodesPerPage + 1;
            const endEpisode = Math.min(currentPage * episodesPerPage, totalEpisodes);
            
            // Create episode buttons
            for (let i = startEpisode; i <= endEpisode; i++) {
                const episodeBtn = document.createElement('button');
                episodeBtn.className = 'episode-btn';
                if (i === currentEpisode) {
                    episodeBtn.classList.add('current');
                }
                episodeBtn.textContent = i;
                episodeBtn.addEventListener('click', () => navigateToEpisode(i));
                episodesGrid.appendChild(episodeBtn);
            }
            
            // Create pagination buttons
            pagination.innerHTML = '';
            
            if (totalPages > 1) {
                const prevBtn = document.createElement('button');
                prevBtn.className = 'pagination-btn';
                prevBtn.textContent = 'Previous';
                prevBtn.disabled = currentPage === 1;
                prevBtn.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        setupEpisodesList();
                    }
                });
                pagination.appendChild(prevBtn);
                
                // Page indicator
                const pageInfo = document.createElement('span');
                pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
                pageInfo.style.padding = '0 10px';
                pageInfo.style.display = 'flex';
                pageInfo.style.alignItems = 'center';
                pagination.appendChild(pageInfo);
                
                const nextBtn = document.createElement('button');
                nextBtn.className = 'pagination-btn';
                nextBtn.textContent = 'Next';
                nextBtn.disabled = currentPage === totalPages;
                nextBtn.addEventListener('click', () => {
                    if (currentPage < totalPages) {
                        currentPage++;
                        setupEpisodesList();
                    }
                });
                pagination.appendChild(nextBtn);
            }
        }
        
        function updateCurrentEpisodeButton() {
            const episodeButtons = episodesGrid.querySelectorAll('.episode-btn');
            episodeButtons.forEach(btn => {
                btn.classList.remove('current');
                if (parseInt(btn.textContent) === currentEpisode) {
                    btn.classList.add('current');
                }
            });
        }
        
        function navigateToEpisode(episodeNumber) {
            if (episodeNumber === currentEpisode) return;
            
            currentEpisode = episodeNumber;
            
            // Update URL without reloading the page
            const newUrl = `/anime/${animeId}/${episodeNumber}`;
            window.history.pushState({}, '', newUrl);
            
            // Load the new episode
            loadEpisode();
        }
        
        async function fetchWithFallback(url, retries = 3, delay = 1000) {
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return response;
            } catch (error) {
                if (retries <= 0) {
                    throw error;
                }
                await new Promise(resolve => setTimeout(resolve, delay));
                return fetchWithFallback(url, retries - 1, delay * 2);
            }
        }
    </script>
</body>
</html>
