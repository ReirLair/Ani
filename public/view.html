<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Stream</title>
    <style>
        :root {
            --primary-color: #1a1a2e;
            --secondary-color: #16213e;
            --accent-color: #0f3460;
            --text-color: #e6e6e6;
            --highlight-color: #4cc9f0;
            --button-color: #3a7bd5;
            --button-hover: #00d2ff;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--primary-color);
            color: var(--text-color);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--accent-color);
            margin-bottom: 20px;
        }

        .back-btn {
            background-color: var(--button-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .back-btn:hover {
            background-color: var(--button-hover);
        }

        .anime-title {
            font-size: 24px;
            margin: 20px 0;
            color: var(--highlight-color);
        }

        .video-container {
            position: relative;
            width: 100%;
            padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
            background-color: black;
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
        }

        .video-container iframe, 
        .video-container video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: none;
        }

        .server-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .server-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        .server-btn.active {
            background-color: var(--highlight-color);
        }

        .server-btn:hover {
            background-color: var(--button-hover);
        }

        .download-section {
            margin: 20px 0;
            background-color: var(--secondary-color);
            padding: 15px;
            border-radius: 8px;
        }

        .download-section h3 {
            margin-top: 0;
            color: var(--highlight-color);
        }

        .download-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .download-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
            text-decoration: none;
            display: inline-block;
        }

        .download-btn:hover {
            background-color: var(--button-hover);
        }

        .episodes-section {
            margin-top: 30px;
        }

        .episodes-section h3 {
            color: var(--highlight-color);
        }

        .episode-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .episode-btn {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            padding: 8px;
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            text-decoration: none;
        }

        .episode-btn:hover, .episode-btn.current {
            background-color: var(--highlight-color);
            color: var(--primary-color);
        }

        .pagination {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .page-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        .page-btn:hover {
            background-color: var(--button-hover);
        }

        .page-btn.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            font-size: 18px;
            color: var(--highlight-color);
        }

        .error-message {
            color: #ff6b6b;
            margin: 20px 0;
            padding: 10px;
            background-color: rgba(255, 0, 0, 0.1);
            border-radius: 4px;
            border-left: 4px solid #ff6b6b;
        }

        .quality-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .quality-btn {
            background-color: var(--secondary-color);
            color: var(--text-color);
            border: 1px solid var(--accent-color);
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }

        .quality-btn:hover {
            background-color: var(--accent-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <a href="/" class="back-btn">‚Üê Back to Home</a>
            <h1 id="animeTitle" class="anime-title">Loading...</h1>
        </header>

        <div class="video-container" id="videoContainer">
            <div class="loading">Loading video...</div>
        </div>

        <div class="server-buttons" id="serverButtons">
            <button class="server-btn active" data-server="animeheaven">AnimeHeaven</button>
            <button class="server-btn" data-server="gogoanime">GogoAnime</button>
        </div>

        <div class="download-section">
            <h3>Download Options</h3>
            <div class="download-buttons">
                <button class="download-btn" id="downloadAnimeHeaven">Download from AnimeHeaven</button>
                <button class="download-btn" id="downloadTokyoInsider">Download from TokyoInsider</button>
                <button class="download-btn" id="download9anime">Download from 9anime</button>
            </div>
            <div id="qualityOptions" class="quality-options" style="display: none;">
                <!-- Quality options will be added here dynamically -->
            </div>
        </div>

        <div class="episodes-section">
            <h3>Episodes</h3>
            <div class="episode-list" id="episodeList">
                <!-- Episodes will be added here dynamically -->
            </div>
            <div class="pagination" id="pagination">
                <!-- Pagination buttons will be added here dynamically -->
            </div>
        </div>
    </div>

    <script>
        // Extract anime ID and episode number from URL
        const pathParts = window.location.pathname.split('/');
        const animeId = pathParts[2];
        let currentEpisode = parseInt(pathParts[3]) || 1;
        let currentPage = 1;
        const episodesPerPage = 50;
        let totalEpisodes = 0;
        let animeInfo = null;
        let currentServer = 'animeheaven';

        // DOM elements
        const animeTitleElement = document.getElementById('animeTitle');
        const videoContainer = document.getElementById('videoContainer');
        const serverButtons = document.getElementById('serverButtons');
        const downloadAnimeHeavenBtn = document.getElementById('downloadAnimeHeaven');
        const downloadTokyoInsiderBtn = document.getElementById('downloadTokyoInsider');
        const download9animeBtn = document.getElementById('download9anime');
        const qualityOptions = document.getElementById('qualityOptions');
        const episodeList = document.getElementById('episodeList');
        const pagination = document.getElementById('pagination');

        // Initialize the page
        document.addEventListener('DOMContentLoaded', () => {
            fetchAnimeInfo();
            setupServerButtons();
            setupDownloadButtons();
        });

        // Fetch anime info from AniList
        async function fetchAnimeInfo() {
            try {
                const query = `
                    query ($id: Int) {
                        Media(id: $id, type: ANIME) {
                            id
                            title {
                                romaji
                                english
                            }
                            episodes
                        }
                    }
                `;

                const variables = {
                    id: parseInt(animeId)
                };

                const response = await fetch('https://graphql.anilist.co', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json',
                    },
                    body: JSON.stringify({
                        query,
                        variables
                    })
                });

                const data = await response.json();
                animeInfo = data.data.Media;
                totalEpisodes = animeInfo.episodes || 1;

                // Set anime title (prefer English, fallback to romaji)
                const animeTitle = animeInfo.title.english || animeInfo.title.romaji;
                animeTitleElement.textContent = `${animeTitle} - Episode ${currentEpisode}`;

                // Load current episode
                loadEpisode(currentEpisode);
                renderEpisodes();
            } catch (error) {
                console.error('Error fetching anime info:', error);
                showError('Failed to load anime information. Please try again later.');
            }
        }

        // Load episode based on current server
        async function loadEpisode(episodeNumber) {
            try {
                videoContainer.innerHTML = '<div class="loading">Loading video...</div>';
                
                const animeTitle = encodeURIComponent(animeInfo.title.english || animeInfo.title.romaji);
                
                if (currentServer === 'animeheaven') {
                    await loadAnimeHeaven(animeTitle, episodeNumber);
                } else if (currentServer === 'gogoanime') {
                    await loadGogoAnime(animeTitle, episodeNumber);
                }
                
                // Update current episode highlight
                updateEpisodeHighlight(episodeNumber);
                animeTitleElement.textContent = `${animeInfo.title.english || animeInfo.title.romaji} - Episode ${episodeNumber}`;
                
                // Update URL without reloading page
                window.history.pushState(null, '', `/anime/${animeId}/${episodeNumber}`);
            } catch (error) {
                console.error('Error loading episode:', error);
                showError('Failed to load episode. Please try another server or check back later.');
            }
        }

        // Load from AnimeHeaven
        async function loadAnimeHeaven(animeTitle, episodeNumber) {
            const response = await fetch(`http://txtorg-anih.hf.space/video?name=${animeTitle}&episode=${episodeNumber}`);
            if (!response.ok) throw new Error('Failed to fetch from AnimeHeaven');
            
            const data = await response.json();
            if (!data.videoUrl) throw new Error('No video URL found');
            
            videoContainer.innerHTML = `
                <video controls autoplay width="100%" height="100%">
                    <source src="${data.videoUrl}" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
            `;
        }

        // Load from GogoAnime
        async function loadGogoAnime(animeTitle, episodeNumber) {
            // First get the episode URL
            const episodeResponse = await fetch(`https://reikerxx-animedl.hf.space/anime/${animeTitle}/${episodeNumber}`);
            if (!episodeResponse.ok) throw new Error('Failed to fetch from GogoAnime');
            
            const episodeData = await episodeResponse.json();
            if (!episodeData.episodeUrl) throw new Error('No episode URL found');
            
            // Then get the iframe URL
            const iframeResponse = await fetch(`https://txtorg-anih.hf.space/iframe?url=${encodeURIComponent(episodeData.episodeUrl)}`);
            if (!iframeResponse.ok) throw new Error('Failed to fetch iframe URL');
            
            const iframeData = await iframeResponse.json();
            if (!iframeData.iframeUrl) throw new Error('No iframe URL found');
            
            // Finally get the video URL
            const videoResponse = await fetch(`https://txtorg-anih.hf.space/q?q=${encodeURIComponent(iframeData.iframeUrl)}`);
            if (!videoResponse.ok) throw new Error('Failed to fetch video URL');
            
            const videoData = await videoResponse.json();
            if (!videoData.url) throw new Error('No video URL found');
            
            videoContainer.innerHTML = `
                <iframe src="${videoData.url}" frameborder="0" allowfullscreen></iframe>
            `;
        }

        // Setup server buttons
        function setupServerButtons() {
            const buttons = serverButtons.querySelectorAll('.server-btn');
            buttons.forEach(button => {
                button.addEventListener('click', () => {
                    buttons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    currentServer = button.dataset.server;
                    loadEpisode(currentEpisode);
                });
            });
        }

        // Setup download buttons
        function setupDownloadButtons() {
            downloadAnimeHeavenBtn.addEventListener('click', async () => {
                try {
                    const animeTitle = encodeURIComponent(animeInfo.title.english || animeInfo.title.romaji);
                    const response = await fetch(`http://txtorg-anih.hf.space/video?name=${animeTitle}&episode=${currentEpisode}`);
                    if (!response.ok) throw new Error('Failed to fetch download link');
                    
                    const data = await response.json();
                    if (!data.videoUrl) throw new Error('No download URL found');
                    
                    // Create a temporary link to force download
                    const link = document.createElement('a');
                    link.href = data.videoUrl;
                    link.download = `${animeTitle}_Episode_${currentEpisode}.mp4`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } catch (error) {
                    console.error('Error downloading from AnimeHeaven:', error);
                    showError('Failed to get download link. Please try again later.');
                }
            });

            downloadTokyoInsiderBtn.addEventListener('click', async () => {
                try {
                    const animeTitle = encodeURIComponent(animeInfo.title.english || animeInfo.title.romaji);
                    const response = await fetch(`https://reaperxxxx-anime.hf.space/api/anime2?name=${animeTitle}&episode=${currentEpisode}`);
                    if (!response.ok) throw new Error('Failed to fetch download links');
                    
                    const data = await response.json();
                    if (!data.Downloads) throw new Error('No download options available');
                    
                    // Clear previous options
                    qualityOptions.innerHTML = '';
                    
                    // Add available quality options
                    for (const [quality, info] of Object.entries(data.Downloads)) {
                        if (info !== "Not available" && info.url) {
                            const qualityBtn = document.createElement('button');
                            qualityBtn.className = 'quality-btn';
                            qualityBtn.textContent = quality;
                            qualityBtn.addEventListener('click', () => {
                                const link = document.createElement('a');
                                link.href = info.url;
                                link.download = `${animeTitle}_Episode_${currentEpisode}_${quality}.${info.url.split('.').pop()}`;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                            });
                            qualityOptions.appendChild(qualityBtn);
                        }
                    }
                    
                    if (qualityOptions.children.length > 0) {
                        qualityOptions.style.display = 'flex';
                    } else {
                        throw new Error('No download options available');
                    }
                } catch (error) {
                    console.error('Error downloading from TokyoInsider:', error);
                    showError('No download options available for this episode.');
                }
            });

            download9animeBtn.addEventListener('click', async () => {
                try {
                    const animeTitle = encodeURIComponent(animeInfo.title.english || animeInfo.title.romaji);
                    const response = await fetch(`https://txtorg-anih.hf.space/api/anime-download?q=${animeTitle}&episode=${currentEpisode}`);
                    if (!response.ok) throw new Error('Failed to fetch download links');
                    
                    const data = await response.json();
                    if (!data.download_links || data.download_links.length === 0) throw new Error('No download options available');
                    
                    // Clear previous options
                    qualityOptions.innerHTML = '';
                    
                    // Add available quality options
                    data.download_links.forEach(item => {
                        const qualityBtn = document.createElement('button');
                        qualityBtn.className = 'quality-btn';
                        qualityBtn.textContent = item.quality;
                        qualityBtn.addEventListener('click', () => {
                            const link = document.createElement('a');
                            link.href = item.link;
                            link.download = `${animeTitle}_Episode_${currentEpisode}_${item.quality}`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                        });
                        qualityOptions.appendChild(qualityBtn);
                    });
                    
                    qualityOptions.style.display = 'flex';
                } catch (error) {
                    console.error('Error downloading from 9anime:', error);
                    showError('No download options available for this episode.');
                }
            });
        }

        // Render episodes list with pagination
        function renderEpisodes() {
            episodeList.innerHTML = '';
            
            const startEpisode = (currentPage - 1) * episodesPerPage + 1;
            const endEpisode = Math.min(startEpisode + episodesPerPage - 1, totalEpisodes);
            
            for (let i = startEpisode; i <= endEpisode; i++) {
                const episodeBtn = document.createElement('a');
                episodeBtn.className = 'episode-btn';
                if (i === currentEpisode) {
                    episodeBtn.classList.add('current');
                }
                episodeBtn.textContent = i;
                episodeBtn.href = `#`;
                episodeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    currentEpisode = i;
                    loadEpisode(currentEpisode);
                });
                episodeList.appendChild(episodeBtn);
            }
            
            renderPagination();
        }

        // Render pagination buttons
        function renderPagination() {
            pagination.innerHTML = '';
            
            const totalPages = Math.ceil(totalEpisodes / episodesPerPage);
            
            // Previous button
            const prevBtn = document.createElement('button');
            prevBtn.className = 'page-btn';
            prevBtn.textContent = 'Previous';
            prevBtn.disabled = currentPage === 1;
            prevBtn.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderEpisodes();
                }
            });
            pagination.appendChild(prevBtn);
            
            // Page numbers
            const maxVisiblePages = 5;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            // Adjust if we're at the end
            if (endPage - startPage + 1 < maxVisiblePages) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            if (startPage > 1) {
                const firstPageBtn = document.createElement('button');
                firstPageBtn.className = 'page-btn';
                firstPageBtn.textContent = '1';
                firstPageBtn.addEventListener('click', () => {
                    currentPage = 1;
                    renderEpisodes();
                });
                pagination.appendChild(firstPageBtn);
                
                if (startPage > 2) {
                    const ellipsis = document.createElement('span');
                    ellipsis.textContent = '...';
                    pagination.appendChild(ellipsis);
                }
            }
            
            for (let i = startPage; i <= endPage; i++) {
                const pageBtn = document.createElement('button');
                pageBtn.className = 'page-btn';
                if (i === currentPage) {
                    pageBtn.style.backgroundColor = var('--highlight-color');
                }
                pageBtn.textContent = i;
                pageBtn.addEventListener('click', () => {
                    currentPage = i;
                    renderEpisodes();
                });
                pagination.appendChild(pageBtn);
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    const ellipsis = document.createElement('span');
                    ellipsis.textContent = '...';
                    pagination.appendChild(ellipsis);
                }
                
                const lastPageBtn = document.createElement('button');
                lastPageBtn.className = 'page-btn';
                lastPageBtn.textContent = totalPages;
                lastPageBtn.addEventListener('click', () => {
                    currentPage = totalPages;
                    renderEpisodes();
                });
                pagination.appendChild(lastPageBtn);
            }
            
            // Next button
            const nextBtn = document.createElement('button');
            nextBtn.className = 'page-btn';
            nextBtn.textContent = 'Next';
            nextBtn.disabled = currentPage === totalPages;
            nextBtn.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    renderEpisodes();
                }
            });
            pagination.appendChild(nextBtn);
        }

        // Update current episode highlight
        function updateEpisodeHighlight(episodeNumber) {
            const episodeButtons = episodeList.querySelectorAll('.episode-btn');
            episodeButtons.forEach(btn => {
                btn.classList.remove('current');
                if (parseInt(btn.textContent) === episodeNumber) {
                    btn.classList.add('current');
                }
            });
        }

        // Show error message
        function showError(message) {
            const errorElement = document.createElement('div');
            errorElement.className = 'error-message';
            errorElement.textContent = message;
            videoContainer.appendChild(errorElement);
        }

        // Handle back/forward navigation
        window.addEventListener('popstate', () => {
            const pathParts = window.location.pathname.split('/');
            const newEpisode = parseInt(pathParts[3]) || 1;
            if (newEpisode !== currentEpisode) {
                currentEpisode = newEpisode;
                loadEpisode(currentEpisode);
            }
        });
    </script>
</body>
</html>
